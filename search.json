[{"title":"Discrete Mathematics (H) Lecture 1-3 Notes","url":"/2025/09/11/discrete-math-lec-1/","content":"Logic\n  \n    \n      Definition: Proposition\n\n    \n    \n      A proposition is a declarative statement that is either true or false.\n\n    \n  \n\nUsually, propositions are condition-based. We can use logical connectives to build more complex propositions:\n\nNegation \nConjunction \nDisjunction \nExclusive or \nImplication \nBiconditional \n\n\n  \n    \n      Definition: Truth Table\n\n    \n    \n      A truth table displays the relationships between truth values of different propositions. The rows of a truth table list out all possible values of all elementary propositions.\n\n    \n  \n\n\n  \n    \n      Definition: Negation\n\n    \n    \n      Let  be a proposition. The statement “It is not the case that ” is called the negation of , denoted by  and read as “not ”.\n\n    \n  \n\n\n  \n    \n      Definition: Conjunction\n\n    \n    \n      Let  and  be propositions. The conjunction of  and , denoted by , is true when both  and  are true and is false otherwise.\n\n    \n  \n\n\n  \n    \n      Definition: Disjunction\n\n    \n    \n      Let  and  be propositions. The disjunction of  and , denoted by , is false when both  and  are false and is true otherwise.\n\n    \n  \n\n\n  \n    \n      Definition: Exclusive Or\n\n    \n    \n      Let  and  be propositions. The exclusive or of  and , denoted by , is true when exactly one of  and  is true and is false otherwise.\n\n    \n  \n\n\n  \n    \n      Definition: Implication\n\n    \n    \n      Let  and  be propositions. The conditional statement (a.k.a. implication) , is the proposition “if , then ”, is false when  is true and  is false, and true otherwise. In ,  is called the hypothesis and  is called the conclusion.\n\n    \n  \n\n is read in a variety of equivalent ways:\n\nif  then \n implies \n is sufficient for \n is necessary for \n follows from \n unless \n only if \n\nThe converse of  is .\nThe contrapositive of  is .\nThe inverse of  is .\n\n  \n    \n      Definition: Biconditional\n\n    \n    \n      Let  and  be propositions. The biconditional statement (a.k.a. bi-conditional) , is the proposition “ if and only if ”, is true when  and  share the same truth value, and is false otherwise.\n\n    \n  \n\n\nA compound proposition that is always true for all possible truth values is called a tautology.\nA compound proposition that is always false for all possible truth values is called a contradiction.\nA compound proposition that is neither tautology nor contradiction is called a contingency.\n\n\n  \n    \n      Definition: Logical Equivalence\n\n    \n    \n      Two proposition are equivalent if they always have the same truth value. \nAlternative definition: The propositions  and  are called logically equivalent if  is a tautology, denoted by  or .\n\n    \n  \n\nLogical Equivalence Laws\n  \n    \n      Distributive Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      De Morgan’s Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Identity Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Domination Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Idempotent Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Double Negation Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Commutative Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Distributive Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Absorption Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Negation Laws\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Useful Law\n\n    \n    \n      \n\n    \n  \nComputer Representation of True and FalseA bit is sufficient to represent two possible values: 0 (false) or 1 (true). A variable that takes on values 0 and 1 is called a Boolean variable. A bit string is a sequence of zero or more bits, the length of such bit strings is the number of bits in the string.\nLimitations of Propositional LogicPropositional logic is the world described in terms of elementary propositions and their logical combinations. Elementary statements typically refer to objects, their properties and relations. But there exists some limitations of it, for example:\n\nRepeated statements for many objects.\nStatements that define the property of a group of objects.To solve this, we need to:\nexplicitly models objects and their properties, and\nallows to make statements with variables and quantify them.\n\nPredicate LogicBasic building blocks of the predicate logic (or first-order logic):\n\nConstant\nVariable\nPredicate\n\n\n  \n    \n      Definition: Predicate\n\n    \n    \n      A predicate is a statement  that contains  variables  and becomes a proposition when specific values are substituted for the variables .\nThe universe (or domain)  of the predicate variables is the set of all values that may be substituted in place of the variables.\nThe truth set of  is the set of all values of the predicate variables s.t. the proposition  is true.\n\n    \n  \n\nThe logical connectives and corresponding rules in propositional logic are all usable in predicate logic.\nThere are two types of quantified statements: universal and existential.\n\n  \n    \n      Definition: Universal Quantification\n\n    \n    \n      The universal quantification of  is the proposition “ is true for all values of  in the universe of discourse.” Denoted by , and is expressed as “for every , .”\n\n    \n  \n\n\n  \n    \n      Definition: Existential Quantification\n\n    \n    \n      The existential quantification of  is the proposition “ is true for some values of  in the universe of discourse.” Denoted by , and is expressed as “for some , .”\n\n    \n  \n\nSuppose that the elements in the universe can be numerated as , then:\n\n is true iff .\n is true iff .\n\n\n  \n    \n      Caution\n\n    \n    \n      The truth values of  and  depend on both the propositional function  and the universe.\n\n    \n  \n\n\n  \n    \n      Caution\n\n    \n    \n      The quantifier has higher precedence than the logical connectives.\n\n    \n  \n\n\n  \n    \n      Tip\n\n    \n    \n      The universal quantifier  is often paired with the implication :The seemingly correctwould mean that everyone is a SUSTech student and is smart!The existential quantifier  is often paired with the conjunction :whilewould be true even if  is not a SUSTech student!\n\n    \n  \n\n\n  \n    \n      De Morgan’s Law for Quantifiers\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Tip\n\n    \n    \n      The order of the quantifiers generally does matter. if the types of the nested quantifiers are the same, the order will have no matter at changing.\n\n    \n  \n\nTheorems and Proofs\n  \n    \n      Definition: Axiom\n\n    \n    \n      An axiom and postulate is a statement or proposition which is regarded as being established, accepted, or self-evidently true.\n\n    \n  \n\n\n  \n    \n      Definition: Theorem\n\n    \n    \n      A theorem is a statement that can be proved to be true.\n\n    \n  \n\n\n  \n    \n      Definition: Lemma\n\n    \n    \n      A lemma is a statement that can be proved to be true, and is used in proving a theorem or proposition.\n\n    \n  \n\nTo show the truth value of a statement follows from other statements, we need to provide a correct supporting argument, a.k.a. proof.\nTypically, a theorem looks like this:\n\n  \n    \n      Definition: Proof\n\n    \n    \n      A proof provides an argument supporting the validity of the statement, and may use premises, axioms, lemmas, results of other theorems, etc.\n\n    \n  \n\nIn formal proofs, steps follow logically from the set of premises, axioms, lemmas, and other theorems.\nSome basic proof methods are:\n\nDirect proof\nProof by contrapositive\nProof by contradiction\nProof by cases\nProof of equivalence\n\nConsider the truth table of the implication:\n\n\n\n\n\n\n\n\n\nT\nT\nT\n\n\nT\nF\nF\n\n\nF\nT\nT\n\n\nF\nF\nT\n\n\nThen:\n\n\n\n\n\ndirect proof proceeds by showing the first row.\nproof by contradiction proceeds by showing the second row.\nproof by contrapositive proceeds by showing the fourth row.\n\nThe proof by cases is based on the following logical equivalence:\nInference Rules of Propositional LogicEvery inference rule represent a tautology that allows us to infer new true statements from existing ones.\n\n  \n    \n      Modus Ponens\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Modus Tollens\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Hypothetical Syllogism\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Disjunctive Syllogism\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Addition\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Simplification\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Conjunction\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Resolution\n\n    \n    \n      \n\n    \n  \n\n\nInference Rules for Quantified Statements\n  \n    \n      Universal Instantiation\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Universal Generalization\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Existential Instantiation\n\n    \n    \n      \n\n    \n  \n\n\n  \n    \n      Existential Generalization\n\n    \n    \n      \n\n    \n  \n\n","tags":["Discrete Mathematics","Notes"]},{"title":"Data Structures and Algorithms (H) Lecture 1 Notes","url":"/2025/09/11/dsaa-lec-1/","content":"Getting Started\n  \n    \n      Definition: Algorithm\n\n    \n    \n      An algorithm is a well-defined computational procedure that takes some input and produces some output.\n\n    \n  \n\nThis means:\n\nIt is a tool for solving a well-specified computational problem.e.g. the sorting problem:\nInput: a sequence of  numbers .\nOutput: a permutation  of the input sequence s.t. \n\nA sequence like  is called a instance of the sorting problem. We expect the algorithm to solve all instances of a specific problem.\nTo define the algorithms precisely, we use a abstract language, pseudocode.\nAn ideal algorithm should be\n\ncorrect\nefficient\neasy to read, cheap to design\netc.\n\n\n  \n    \n      Definition: Correctness of Algorithm\n\n    \n    \n      An algorithm is correct if for every input instance it halts with the corrent output. A correct algorithm solves the problem.\n\n    \n  \n\nTo show the correctness of algorithms, we need to make mathematical reasoning.\nNext, to measure the running time of a given algorithm, we need a model that provides a good level of abstraction:\n\nGives a good idea about the time an algorithm needs.\nAllows us to compare different algorithms.\nWithout getting bogged down with details.\n\n\n  \n    \n      Definition: Random-access Machine Model\n\n    \n    \n      A generic random-access machine, where instructions are executed one after another, with no concurrent operations.The elementary operations are:\n\nArithmetic operations\nLogical operations, shifts, comparisons\nData movement: variable assignments\nControl instructions: loops, subroutine/method calls\n\nThe RAM model assumes that each elementary operations takes the same amount of time (a constant time).\n\n    \n  \n\nThen to measure the runtime, we only need to count the number of elementary operations in the RAM model, this is known as the common cost model.\nBut we often abstract from the constants and concrete operation numbers, and focus on the asymptotic growth of runtime with problem size.\nExample: Insertion Sort\nCorrectnessTo prove the correctness of the above algorithm, we use proof by loop invariants, a popular way of proving correctness of algorithms with loops.\n\n  \n    \n      Definition: Loop Invariant\n\n    \n    \n      A loop invariant is a statement that is always true and that reflects the progress of the algorithm towards producing a correct output.\n\n    \n  \n\n\nInitialization: the loop invariant is true at initialization.\nThis part is often trivial.\n\n\nMaintenance: if the loop invariant is true after  iteration, it is also true after  iterations.\nEssentially the same as the proof by induction.\n\n\nTermination: when the algorithm terminates, the loop invariant tells that the algorithm is correct.\n\nApplying this to the insertion sort, we get:\n\nLoop invariant: At the start of each iteration of the for loop of lines 1-9, the subarray  consists of the elements originally in , but in sorted order.\nInitialization: For  the subarray  is the original  and it is sorted (trivial).\nMaintenance: The while loop moves  one position to the right and inserts  at the correct position . Then  contains the original , but in sorted order.\nTermination: The for loop ends when . Then the loop invariant  says that the array contains the original  in sorted order.\n\nRuntime of Insertion Sort (In a naive way)A naive way of calculating runtime of insertion sort is:\n\nAssume that line  take  time to run once (cost).\nCount the number the line  has executed.\nSum up the product of cost and execution time.\n\nDefine  as the number of times the while loop is executed for that :\n\n\n\nLine\nCost\nTimes\n\n\n\n1\n\n\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n5\n\n\n\n\n6\n\n\n\n\n7\n\n\n\n\n8\n\n\n\n\n9\n\n\n\n\nThen the runtime of the algorithm is:\n\n\nBest case: the array is already sorted, in that case, :\n\n\tSo it’s linear w.r.t. the input size.\n\nWorse case: the array is inversely ordered, in that case, :\n\n\tSo it’s quadratic w.r.t. the input size\n","tags":["Notes","Data Structures and Algorithms"]},{"title":"Data Structures and Algorithms (H) Lecture 2 Notes","url":"/2025/09/18/dsaa-lec-2/","content":"Runtime and Asymptotic NotationIn the previous lecture, we showed a naive way to analyze the runtime of algorithms. But this naive approach is very heavy and can be particularly troublesome when comparing algorithms that have complex runtime expressions. To simplify this, we introduce the asymptotic notation. A high-level intuition of the asymptotic notation is that it captures, and only captures the growth speed of functions.\nThe running time of every instance is sandwiched between the best case and the worst case running time. The worst case is often more important because:\n\nit guarantees that the algorithm will never take longer time.\nfor some algorithms, the worst case is quite frequent.\noften the average case is as bad as the base case.Where the average case is defined as the performance on “average” input. e.g. for sorting it means that we assume that every possible permutation is equally likely.\n\nSome key observations:\n\nthe biggest-order term (e.g.  vs. ) dominates the runtime as  grows.\nand how the runtime scales with  is more important than constant factors (for sufficiently large ).\nadditive smaller order terms become irrelevant for large .\nwe care about large  because small problems are always easy to solve.\n\nAsymptotic Notation: \n  \n    \n      Definition:  Notation\n\n    \n    \n      For a given non-negative function  we denote by  the set of functionsA function  belongs to the set  if it can be “sandwiched” between  and  for sufficiently large . By the convention of computer science literature, we write  instead of .We say that  is an asymptotically tight bound of .\n\n    \n  \n\nIntuitively,  means that captures  grows essentially the same speed as .\n\n  \n    \n      Example\n\n    \n    \n      \n\n    \n  \n\n expresses tight upper and lower bounds on . There are other two notations:\n\nUse  if we only want to express an upper bound.\nUse  if we only want to express a lower bound.The formal definition of these two new notations are similar:\n\n\n  \n    \n      Definition:  Notation\n\n    \n    \n      For a given non-negative function  we denote by  the set of functionsFor a given non-negative function  we denote by  the set of functions\n\n    \n  \n\n\n  \n    \n      Tip\n\n    \n    \n      \n\n    \n  \n\nWe also have  and  indicate strictly slower and faster growth, respectively:\nAn overview of asymptotic notation:\n\n\n\nNotation\nMeaning\nAnalogy\n\n\n\n\n grows at most as fast as \n\n\n\n\n grows at least as fast as \n\n\n\n\n grows as fast as \n\n\n\n\n grows slower than \n\n\n\n\n grows faster than \n\n\n\n\n  \n    \n      Caution\n\n    \n    \n      Always remember that  is a “incorrect” convention for expressing .\n\n    \n  \n\nBy using the asymptotic notation, we can now describe the runtime of insertion sort as:\nCommon runtimes\n\n\nMathematical expression\nName\n\n\n\n\nlogarithmic time\n\n\n\nlinear time\n\n\n\nquadratic time\n\n\n\ncubic time\n\n\n for \npolynomial time\n\n\n\nexponential time\n\n\n\n  \n    \n      Tip\n\n    \n    \n      \nEvery polynomial of  grows strictly slower than every polynomial of .\nEvery polynomial of  grows strictly slower than every exponential function.\n\n\n    \n  \n\nHow to find \nIt is often helpful to divide by , e.g.  Then try  sandwiching the constant term.\nRemember that .\nAlso remember that inequalities need to hold for all .\nNo need to invest time to find the best possible constants.\n\nPractical rules to make runtime analysis simpleFor two non-negative functions  and :\n\nSlower functions can be ignored:\nAsymptotic times can be multiplied:\n\nAsymptotic notation: comparing setsIstrue or false? (Tip: think of  as a placeholder for an anonymous function from the set  of all functions that grow linearly in .)\nSuch statement is true if no matter how the anonymous functions are chosen on the left of the equal sign, there is a way to choose the anonymous functions on the right of the equal sign to make the equation valid.\n\n  \n    \n      Example\n\n    \n    \n      \n is true because .\n is false, e.g.  but .\n\n\n    \n  \n\n","tags":["Notes","Data Structures and Algorithms"]},{"title":"C++元编程教程00：模板基础回顾","url":"/2025/04/09/cpp-metaprogramming-00/","content":"C++模版基础回顾前言：为什么我们需要模版？在使用编程语言进行程序设计的时候，有这样一个概念会反复的出现，这就是抽象（abstraction）。以一个简单的返回两数最大值的函数max为例：\nauto max(int lhs, int rhs) -&gt; int &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;\n这个函数可以看作对一类实际的表达式2 &gt; 1 ? 2 : 1进行了抽象，将1、2这样实际的数值抽象为了函数形参lhs、rhs，从而将代码逻辑从具体的表达式值中解耦。抽象的强大之处在于它能极大地减少重复代码，如果一段代码逻辑在我们所写的代码中反复的出现，将其抽象为一个函数可以有效的减少我们的工作量。在使用max函数时，我们可能会发现我们也需要对浮点数求最大值，这时候我们可能会想到通过重载函数的方式添加支持：\nauto max(float lhs, float rhs) -&gt; float &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;auto max(double lhs, double rhs) -&gt; double &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;\n添加一两个重载的工作量尚可接受，但是如果我们还想支持更多的数据类型，甚至是不同的数据类型之间的混合比较的时候，那么需要编写的代码很快就会增长到无法接受的程度。为了避免代码重复，我们就需要继续使用抽象，类似于前文将逻辑与具体的表达式值解耦类似，我们进一步将逻辑与具体的类型解耦。为此，我们需要使用模板(template)：\ntemplate &lt;typename T&gt;auto max(T lhs, T rhs) -&gt; T &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;\n与函数参数类似，我们通过让类型也成为可变的形参来完成抽象。每当需要在某个类型的值上使用max函数（严谨来说，现在应该叫做函数模板）时，我们除了需要传入lhs、rhs之外，还需要传入它们的类型：\nauto main() -&gt; int &#123;\tint result1 = max&lt;int&gt;(1, 2);\tdouble result2 = max&lt;double&gt;(1.3d, 4.2d);\tchar result3 = max&lt;char&gt;(&#x27;a&#x27;, &#x27;c&#x27;);&#125;\n这个简单的max函数，精准地反映了泛型编程（Generic Programming）的核心思想：不为每种类型重复编写逻辑相同的代码，而是将类型本身参数化，让编译器在编译期自动生成不同类型的版本。这种思想，不仅直接催生了C++标准容器库的产生，更成为现代C++的基石之一。\n函数模板基本语法函数模板（Function template）的一般定义方式为：\ntemplate &lt;模板形参列表&gt;函数声明\n以前文中的max函数模板为例\ntemplate &lt;typename T&gt;auto max(T lhs, T rhs) -&gt; T &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;\n可以看到，max具有一个模板形参typename T，typename表示T是一个类型形参，所以当在调用max的时候，T只能是一个类型（如int）而不能是一个值（如42）。我们也可以使用class T来声明类型形参，这种写法完全等价于typename T，但笔者认为使用typename T更加清晰（使用class容易让人认为T只能说一个类，但实际上T能是任意类型）。\n函数模板实例化函数模板并不是实际的函数，单纯的定义一个函数模板并不会在编译后生成任何代码，为了使用函数模板，我们需要实例化（instantiate）模板：\ntemplate &lt;typename T&gt;auto max(T lhs, T rhs) -&gt; T &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;auto main() -&gt; int &#123;\t//显式地提供模板实参\tint result1 = max&lt;int&gt;(114, 514);\t//如果模板实参能从上下文推导出来，那么我们不必提供它\tdouble result2 = max&lt;&gt;(4.2, 1.3);\t//我们也可以直接省略尖括号对\tdouble result3 = max(4.2, 1.3);\tstd::println(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, result1, result2, result3);&#125;\nCompiler Explorer链接我们可以将实例化看作编译器自动地将函数定义中对模板形参的使用全部替换为模板实参的过程，上面的代码在编译时，编译器会实例化产生两个max函数，我们将这些生成的函数成为函数模板的实例：\nauto max(int lhs, int rhs) -&gt; int &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;auto max(double lhs, double rhs) -&gt; double &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;\n注意：\n\n同一个函数模板实例化出的不同实例间没有任何关系，如同两个相互独立的函数。\n如果一个函数模板已经对某些模板实参完成实例化，那么再次用这些模板实参来调用函数模板将不会再次实例化，而是使用之前已经产生的实例。（注意在上面的例子中，我们在T=double的情况下使用了两次max，而实际只实例化生成了一个函数）\n\n函数模板的实例化可以分为显式实例化（Explicit Template Instantiation）和隐式实例化（Implicit Template Instantiation）两种，继续以max模板为例：\ntemplate &lt;typename T&gt;auto max(T lhs, T rhs) -&gt; T &#123;\treturn lhs &gt; rhs ? lhs : rhs;&#125;//显式实例化templateauto max&lt;int&gt;(int, int) -&gt; int;//如果模板实参能够从上下文推导，则我们可以将其省略templateauto max&lt;&gt;(short, short) -&gt; short;//当然也可以连尖括号一起省略templateauto max(long, long) -&gt; long;auto main() -&gt; int &#123;\t//如果我们使用了一个函数模板而该函数模板还没有被实例化过，则会发生隐式实例化：\t//max&lt;double&gt;没有实例化，故此处发生隐式实例化\tdouble result1 = max(4.2, 1.3);\t//max&lt;int&gt;已经被实例化过了，则此处不会发生任何实例化\tint result2 = max&lt;int&gt;(114, 514);&#125;\n与函数形参类似，我们也可以为模板形参指定默认值：\ntemplate &lt;typename T = int&gt;auto foo(T t) -&gt; T &#123;\treturn t;&#125;auto main() -&gt; int &#123;\t//此时默认T = int\tint result1 = foo(1);\t//注意，当推导出的实参与形参默认值不一致时，以推导出的实参为准\tauto result2 = foo(4.2f);\tstatic_assert(not std::same_as&lt;decltype(result2), int&gt;);&#125;\n\n非类型模板形参既然我们有只接受类型的类型模板形参，自然也有非类型模板形参（NTTP，Nontype Template Parameter），NTTP接受一个对象的值：\ntemplate &lt;int N&gt;auto foo() -&gt; int &#123;\treturn N;&#125;auto main() -&gt; &#123;\tstd::println(&quot;&#123;&#125;&quot;, foo&lt;42&gt;());&#125;\nNTTP的类型可以不是具体类型：\ntemplate &lt;auto N&gt;auto print() -&gt; void &#123;\tstd::println(&quot;&#123;&#125;&quot;, N);&#125;auto main() &#123;\tprint&lt;114514&gt;();\tprint&lt;4.2f&gt;();\tprint&lt;true&gt;();\t\t//这行代码没法通过编译，详细解释见下\tprint&lt;std::string&#123;&quot;awa&quot;&#125;&gt;();&#125;\n为什么在上面的例子中，我们不能使用std::string来作为非类型模板实参呢？这是由于C++为了保证相同的模板实参列表所对应的模板实例是唯一的，换而言之就是需要判断模板实参之间的相等性。对于类型模板实参而言，其相等性判断非常容易实现（即判断两个类型是否为同一类型）。但是对于非类型模板实参，判断其相等性可能会较为复杂，同样以std::string为例，假设我们有两个std::string对象：\nstd::string str1&#123;&quot;awa&quot;&#125;;std::string str2&#123;&quot;awa&quot;&#125;;\n在忽略短字符串优化（SSO，Short String Optimization）和字符串常量池优化的情况下，这两个std::string对象的内部指针会指向两个不同的内存地址，但是两个字符串的存储内容是相同的，这就会造成相等性判断时的歧义：单从类型的定义上看，编译器没法知道你需要比较两个std::string的存储内容，只能从最简单的比较相应成员变量的方式来判断相等性，然而这会导致编译器认为这两个对象是不相等的，从而导致以下两行代码（假设它们能通过编译）：\nprint&lt;str1&gt;();print&lt;str2&gt;();\n所指的实际上是不同的模板实例，这显然与我们的预期不一致。为了解决这个问题，C++规定用于NTTP的对象的类型必须是结构化类型（Structural Type），结构化类型的定义较为复杂，此处不展开讲解，详细定义参见CppReference上相关页面。至于NTTP的进一步的引用场景，我们会在后续章节详细讲解。\n简写函数模板对于一些简单的函数模板，如上文例子中所用的max，C++20标准引入了一种更为简洁的写法，称为简写函数模板（Abbreviated Function Template）：\nauto max(auto lhs, auto rhs) &#123;\treturn (lhs &gt; rhs) ? lhs : rhs;&#125;\n这种写法相当于：\ntemplate &lt;typename T1, typename T2&gt;auto max(T1 lhs, T2 rhs) &#123;\treturn (lhs &gt; rhs) ? lhs : rhs;&#125;\n简写函数模板这个特性非常直观且容易理解，故此处不再展开。\n转发引用与引用折叠在使用模板时，我们经常会想要保留原实参的表达式的值类别，通俗得讲就是左值和右值（关于什么是左值和右值不在本教程的范围之内，如果你不了解，推荐阅读HackingCpp上关于移动语义的这一章），这个时候就要用到转发引用（Forwarding Reference）：\ntemplate &lt;typename T&gt;auto foo(T &amp;&amp;t) -&gt; void &#123;&#125;auto main() -&gt; int &#123;\t//传递右值，T推导为int，函数形参为int &amp;&amp;t\tfoo(4);\t//传递左值，T推导为int&amp;，函数形参为int &amp; &amp;&amp;t，引用折叠后变为int &amp;t\tint a = 42;\tfoo(a);&#125;\n引用折叠规则（Reference Collapsing Rule）可以用一句话来总结：右值引用的右值引用折叠成右值引用，所有其他组合均折叠成左值引用。\nusing LRef = int&amp;;using RRef = int&amp;&amp;;auto main() -&gt; int &#123;\tint n = 42;\tLRef &amp;ref1 = n; //LRef &amp;折叠为int &amp;\tLRef &amp;&amp;ref2 = n;//LRef &amp;&amp;折叠为int &amp;\tRRef &amp;ref3 = n; //RRef &amp;折叠为int &amp;\tRRef &amp;&amp;ref4 = 1;//RRef &amp;&amp;折叠为int &amp;&amp;&#125;\n如果我们想将转发引用传递给另一个函数，并让转发引用继续保持其值类别，就需要使用标准库中的转发函数std::forward：\ntemplate &lt;typename T&gt;auto foo(T &amp;&amp;t) -&gt; void &#123;\t//将t完美转发给bar函数\tbar(std::forward&lt;T&gt;(t));&#125;\n\n模板形参包在实际场景中，我们常常会遇到需要编写变长参数的函数的情景，我们可以通过C++模板来实现这种函数。以一个能够接收任意多参数并计算所有参数的和并返回的函数sum为例：\nint sum_result = sum(1, 4, 6, 8);std::println(&quot;&#123;&#125;&quot; sum_result);    //输出19\n为了实现这样的函数，我们需要用到模板形参包（Template Parameter Pack）：\ntemplate &lt;typename ... ArgTypes&gt;auto sum(ArgTypes ... args) -&gt; std::common_type_t&lt;ArgTypes...&gt; &#123;\treturn (args + ...);&#125;\n其中，typename ... ArgTypes声明了一个类型模板形参包（Type Template Parameter Pack，我不说你应该也能猜到还有非类型模板形参包），并通过这个模板形参包声明了一个函数形参包（Function Parameter Pack）ArgTypes ... args。ArgTypes包含了所有函数形参的类型，而args则包含了函数所有的参数。这些包能够接受任意数量的实参，比如：\nauto main() -&gt; int &#123;\tint result1 = sum&lt;int, int, int, int&gt;(1, 3, 6, 9);\t//模板形参包当然能够被推导，所以上面这行代码也可以写为\tint result2 = sum(1, 3, 6, 9);\t//不同的类型也可以\tauto result3 = sum(1, 4.2f, 6ull);\t\tstd::println(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, result1, result2, result3);&#125;\nCompiler Explorer链接以上几行代码会导致以下实例的产生：\ntemplateauto sum(int, int, int, int) -&gt; int;template auto sum(int, float, unsigned long long) -&gt; float;\n除了声明形参包之外，sum函数还用到了两个特性：包展开（Pack Expansion）和折叠表达式（Fold Expression），我们逐一讲解这些特性。\n包展开想要使用一个形参包里的内容，就需要用到包展开。所谓包展开，就是将包在代码中按照特定的模式展开成为一个列表，以sum函数的返回类型为例：\nstd::common_type_t&lt;ArgTypes...&gt;\n其中，std::common_type_t是C++标准元编程库中的一个类型特征（Type Trait），它的作用就是找出它的模板实参的公共类型，也就是所有模板实参都能显式转换到的类型。这个类型特征的原理我们会在后面的章节讲到。而ArgTypes...就是我们所说的包展开。假设ArgTypes接受了三个类型：int, float, unsigned long long，那么包展开的结果为\nstd::common_type_t&lt;int, float, unsigned long long&gt;\n我们将ArgTypes...中的ArgTypes称为包展开的模式（Pattern），包展开会将包中的每个元素按照我们所指定的模式展开成为一个逗号分隔的列表，比如：\ntemplate &lt;typename ... ArgTypes&gt;//模板形参包展开为bool, float, char const*auto foo(ArgTypes ... args) -&gt; void &#123;//函数形参包展开为bool arg0, float arg1, char const *arg2\targs...;//展开为arg0, arg1, arg2\tArgTypes...;//展开为bool, float, char const *\t&amp;args...;//展开为&amp;arg0, &amp;arg1, &amp;arg2&#125;auto main() -&gt; int &#123;\tfoo(true, 4.2f, &quot;awa&quot;);&#125;\n一般而言，常见的包展开方式有：\n\n递归展开：通过递归模板实例化逐个处理参数\n逗号运算符展开：结合逗号运算符生成初始化列表\n初始化列表展开：利用&#123;&#125;初始化语法展开通过这些包展开形式，我们就可以写出一些有用的函数。示例1：递归展开求和：\n\n//递归模板实例化终止条件：只有一个实参template &lt;typename T&gt;auto accumulate(T value) -&gt; T &#123;\treturn value;&#125;//递归展开参数包template &lt;typename T, typename ... Args&gt;auto accumulate(T first, Args ... args) -&gt; T &#123;\treturn first + accumulate(args...);&#125;auto main() -&gt; int &#123;\tauto result = accumulate(1, 4.3f, 5.6, 7l);\t//递归实例化步骤：\t//1. T=int, Args=&lt;float, double, long&gt;，accumulate(4.3f, 5.6d, 7l)\t//2. T=float, Args=&lt;double, long&gt;，递归调用accumulate(5.6d, 7l)\t//3. T=double, Args=&lt;long&gt;，递归调用accumulate(7l)\t//4. T=long，到达递归终止条件\tstd::println(&quot;&#123;&#125;&quot;, result);&#125;\nCompiler Explorer链接示例2：使用逗号运算符展开输出所有实参\ntemplate &lt;typename ... ArgTypes&gt;auto printAll(ArgTypes ... args) -&gt; void &#123;//展开为char const *arg0, char arg1, int arg2, double arg3\tint dummy_array[] = &#123;(std::println(&quot;&#123;&#125;&quot;, args), 0)...&#125;;\t//展开为&#123;(std::print(&quot;&#123;&#125;&quot;, arg0), 0), (std::print(&quot;&#123;&#125;&quot;, arg1), 0), (std::print(&quot;&#123;&#125;&quot;, arg2), 0), (std::print(&quot;&#123;&#125;&quot;, arg3), 0)&#125;&#125;auto main() -&gt; int &#123;\tprintAll(&quot;awa&quot;, &#x27;o&#x27;, 42, 114.514);&#125;\nCompiler Explorer链接对于这个例子，没有接触过形参包的人总是会写出这样的包展开：\ntemplate &lt;typename ... ArgTypes&gt;auto printAll(ArgTypes ... args) -&gt; void &#123;\t(std::println(&quot;&#123;&#125;&quot;, args)...;&#125;\n但实际上这是不行的，这是因为包展开需要在一定的包展开场所中进行，包展开场所的完整列表相当长，故此处不做展开，如有需要可以查看CppReference相关页面。一般而言，常用的包展开场所有函数或模板的实参列表，及大括号&#x2F;圆括号包围的初始化器。示例3：多个包的同时展开我们可以在一个包展开中同时展开多个包，当然，这些包的长度必须一致，我们可以使用sizeof...(pack)来获取包的长度（这个例子里使用了模板类，但是不是很深入，如果你看不懂可以先行阅读一下下一节[[#类模板]]的基础部分）：\ntemplate &lt;typename ... Args1&gt;struct Zip &#123;\ttemplate &lt;typename ... Args2&gt;\tstruct With &#123;\t\t//检查两个形参包的长度是否一致，若不一致则给出报错信息\t\tstatic_assert(sizeof...(Args1) == sizeof...(Args2), &quot;The two packs must have the same length&quot;);\t\t\t\tusing type = std::tuple&lt;std::pair&lt;Args1, Args2&gt;...&gt;;\t\t//包展开结果为：\t\t//std::tuple&lt;std::pair&lt;int, bool&gt;, std::pair&lt;float, double&gt;, std::pair&lt;char, std::string&gt;&gt;\t&#125;;&#125;;auto main() -&gt; int &#123;\tZip&lt;int, float, char&gt;::With&lt;bool, double, std::string&gt;::type zipped&#123;\t\t&#123;42, true&#125;,\t\t&#123;11.4f, 5.14&#125;,\t\t&#123;&#x27;a&#x27;, &quot;wa&quot;&#125;\t&#125;;&#125;\n示例4：嵌套包展开若包展开内嵌于另一个包展开中，那么包展开按从里到外的顺序依次进行：\ntemplate &lt;typename ... ArgTypes&gt;auto foo(ArgTypes ... args) -&gt; void &#123;\tbar(meow(args...) + args...);\t//首先将内层包展开meow(args...)展开为meow(1, 2, 3)\t//随后将内层包展开的结果进行外层包展开\t//最终结果为bar(meow(1, 2, 3) + 1, meow(1, 2, 3) + 2, meow(1, 2, 3) + 3)&#125;auto main() -&gt; int &#123;\tfoo(1, 2, 3);&#125;\n折叠表达式通过刚才的例子，不难发现包展开的语法较为复杂，且在处理计算的时候（如上文中的sum函数）时较为复杂。C++17标准中所引入的折叠表达式，可以让我们通过简洁的方式来完成这些包展开。在函数模板\ntemplate &lt;typename ... ArgTypes&gt;auto sum(ArgTypes ... args) -&gt; std::common_type_t&lt;ArgTypes...&gt; &#123;\treturn (args + ...);&#125;\n中，(args + ...)就是一个折叠表达式。折叠表达式的语法为：\n(形参包 运算符 ...)            //一元右折叠(... 运算符 形参包)            //一元左折叠(形参包 运算符 ... 运算符 初始值)//二元右折叠(初始值 运算符 ... 运算符 形参包)//二元左折叠\n注意折叠表达式的括号是不可省略的。一个折叠表达式是左折叠还是右折叠，取决于...出现在形参包的左侧还是右侧。左折叠和右折叠的区别是展开后的括号结合性：\n\n一元右折叠：(E op ...)展开为(E1 op (E2 op (... op (EN-1 op EN))))\n一元左折叠：(... op E)展开为((((E1 op E2) op ...) op EN-1) op EN)\n二元右折叠：(E op ... op init)展开为 (E1 op (E2 op (... op (EN-1 op (EN op init)))))\n二元左折叠：(init op ... op E)展开为(((((init op E1) op E2) op ...) op EN-1) op EN)以sum函数模板为例：\n\nauto main() -&gt; int &#123;\tint result = sum(1, 1, 4, 5, 1, 4);\t//折叠表达式展开为：\t//(1 + (1 + (4 + (5 + (1 + 4)))))&#125;\n我们也可以使用其他运算符，比如逻辑与&amp;&amp;：\ntemplate &lt;typename ... ArgTypes&gt;auto allTrue(ArgTypes ... args) -&gt; bool &#123;\treturn (args &amp;&amp; ...);&#125;\n注意，左折叠和右折叠会影响计算顺序，因此如果运算符不满足结合性，那么左折叠和右折叠的计算结果也是不同的：\ntemplate &lt;typename ... ArgTypes&gt;auto rightFoldSubtract(ArgTypes ... args) -&gt; std::common_type_t&lt;ArgTypes...&gt; &#123;\treturn (args - ...);&#125;template &lt;typename ... ArgTypes&gt;auto leftFoldSubtract(ArgTypes ... args) -&gt; std::common_type_t&lt;ArgTypes...&gt; &#123;\treturn (... - args);&#125;auto main() -&gt; int &#123;\tint result1 = leftFoldSubtract(1, 2, 3);\tint result2 = rightFoldSubtract(1, 2, 3);\t//result1 = ((1 - 2) - 3) = -4\t//result2 = (1 - (2 - 3)) = 2\tstd::println(&quot;&#123;&#125; &#123;&#125;&quot;, result1, result2);&#125;\nCompiler Explorer链接将折叠表达式与逗号运算符相结合，我们能够更加优雅的写出很多东西，比如printAll函数模板可以简化成：\ntemplate &lt;typename ... ArgTypes&gt;auto printAll(ArgTypes ... args) -&gt; void &#123;\t((std::println(&quot;&#123;&#125;&quot;, args), 0), ...);&#125;\n包索引在C++26之前，我们并没有一个直接访问包中第n个元素的方式，唯一使用形参包的方式就是将其展开。为了访问第n个元素，我们需要使用一个递归模板：\ntemplate&lt;size_t N, typename... Ts&gt;struct GetNthType;//终止条件：当 N=0 时，捕获第一个类型template&lt;typename T, typename... Ts&gt;struct GetNthType&lt;0, T, Ts...&gt; &#123;    using type = T;&#125;;//递归条件：递减索引 N，继续处理剩余参数包template&lt;size_t N, typename T, typename... Ts&gt;struct GetNthType&lt;N, T, Ts...&gt; &#123;    using type = typename GetType&lt;N - 1, Ts...&gt;::type;&#125;;//使用示例using ThirdType = GetNthType&lt;2, int, double, char&gt;::type; //char\n为了实现GetNthType，此处使用了模板特化，模板特化会在[[#模板特化与部分特化]]一节中详细讲解。这种方法不仅效率低下（尝试思考一下获取第n个元素需要实例化多少个模板），而且不够通用（显然GetNthType只能处理类型形参包）。为了解决这个问题，C++26标准引入了包索引（Pack Indexing），包索引的语法如下：\n形参包...[索引]\n这一特性大大简化了跟包相关的模板代码。将包索引和折叠表达式结合在一起，我们能够写出非常简洁优雅的代码：\ntemplate &lt;std::size_t ... Indexes, typename ... ArgTypes&gt;auto sampleSum(ArgTypes ... args) -&gt; std::common_type_t&lt;ArgTypes...&gt; &#123;\treturn (args...[Indexes] + ...);//将Indexes对应的所有args中的元素相加&#125;auto main() -&gt; int &#123;\tauto result = sampleSum&lt;1, 3, 5&gt;(1, 9, 1, 9, 8, 1, 0);//result = 9 + 9 + 1\tstd::println(&quot;&#123;&#125;&quot;, result);//输出19&#125;\nCompiler Explorer链接\n类模板与函数模板相类似，我们也可以声明类模板（Class Template），类模板的语法与函数模板非常类似：\ntemplate &lt;模板形参列表&gt;类声明\n类模板的一大使用案例是实现容器，标准库当中常用的std::vector、std::map等容器都是类模板。在此我们通过实现一个简单的固定容量容器FixedArray来演示类模板的使用：\ntemplate &lt;typename ElementType&gt;struct FixedArray &#123;\tElementType storage[16];&#125;;\n与函数模板类似，类模板并不是实际存在的类，在不进行实例化的情况下编译器不会为类模板生成任何代码。要使用类模板，首先要做的就是实例化：\ntemplate &lt;typename ElementType&gt;struct FixedArray &#123;\tElementType storage[16];&#125;;auto main() -&gt; int &#123;\t//实例化FixedArray&lt;char&gt;\tFixedArray&lt;char&gt; array1&#123;&#x27;t&#x27;, &#x27;e&#x27;, &#x27;m&#x27;, &#x27;p&#x27;, &#x27;l&#x27;, &#x27;a&#x27;, &#x27;t&#x27;, &#x27;e&#x27;&#125;;\t//C++17添加了类模板实参推导特性（Class Template Argument Deduction, CTAD）\t//在可以推导出模板实参的上下文中我们可以省略模板实参\tFixedArray array2&#123;1.3f, 2.6f, 3.9f&#125;;\tfor (auto elem : array1.storage) &#123;\t\tstd::print(&quot;&#123;&#125; &quot;, elem);\t&#125;\tstd::println(&quot;&quot;);\tfor (auto elem : array2.storage) &#123;\t\tstd::print(&quot;&#123;&#125; &quot;, elem);\t&#125;&#125;\nCompiler Explorer链接类模板的显式实例化较函数模板更加复杂，我们可以一次性显式实例化整个类模板，也可以单独实例化类中的成员（包括成员函数、成员类、静态成员变量）：\ntemplate &lt;typename T&gt;class Foo &#123;\tstatic inline int demo_static_member = 42;\t\tauto demo_function() -&gt; void &#123;&#125;\t\tclass Bar &#123;&#125;;&#125;;//实例化整个类templateclass Foo&lt;int&gt;;//实例化单个成员函数，注意模板参数列表的摆放位置templateauto Foo&lt;char&gt;::demo_function() -&gt; void;//实例化单个静态成员变量templateint Foo&lt;double&gt;::demo_static_member;//实例化单个成员类templateclass Foo&lt;bool&gt;::Bar;\n类模板的隐式实例化与函数模板类似，当我们需要使用一个被完整定义的类模板且该类模板没有对应显式实例化的时候，隐式实例化就会发生：\ntemplate &lt;typename ElementType&gt;struct FixedArray &#123;\tElementType storage[16];&#125;;templatestruct FixedArray&lt;int&gt;;auto main() -&gt; &#123;\t//已经有对应的显式实例化，故此处不发生隐式实例化\tFixedArray&lt;int&gt; array1&#123;&#125;;\t//没有对应的显式实例化，故此处发生隐式实例化\tFixedArray&lt;double&gt; array2&#123;&#125;;\t//使用一个类型的指针类型不要求该类型有完整定义，故此处不发生隐式实例化\tFixedArray&lt;char&gt;* array_ptr = nullptr;&#125;\n在上面这个例子中，最后一处使用FixedArray&lt;char&gt;*指针的例子尤其值得注意。由于使用一个类型的指针类型并不需要该类型有定义，故此行代码不会触发隐式实例化。\n\n这是因为C++作为静态类型语言，需要在定义一个类型的变量之前知道该类型的大小，而指针类型的大小仅由平台决定，与指针所指向的类型大小无关，故不需要指针指向的类型有完整定义。\n\n类模板实参推导类模板实参推导（CTAD，Class Template Argument Deduction）可以通过初始化表达式的类型来自动推导模板实参，CTAD的推导规则相当复杂，此处不进行展开说明，如有需要可以参考CppReference上的CTAD一节。对于简单的类模板，CTAD可以很方便的自动推导出对应的模板实参，但是如果类较为复杂或者有特殊处理需求，导致CTAD不起作用时，可以通过定义推导指引(Deduction Guides)来改变CTAD的行为。推导指引的语法如下：\ntemplate &lt;模板形参列表&gt;模板名(形参列表) -&gt; 模板名&lt;推导结果&gt;\n为了演示推导指引的作用，我们通过向FixedArray加入一个int类型的非类型模板形参来使其支持存储指定长度的数组：\ntemplate &lt;typename ElementType, int Length&gt;struct FixedArray &#123;\tElementType storage[Length];&#125;;auto main() -&gt; int &#123;\tFixedArray&lt;int, 4&gt; array&#123;1, 2, 3, 4&#125;;&#125;\n很自然的，我们期望FixedArray能够通过初始化列表来自动推导Length：\n//这样写既简洁又不容易出错，但很可惜CTAD不支持这种情况下的模板实参推导FixedArray array&#123;1, 2, 3, 4&#125;;\n为了让CTAD能自动完成类似推导，我们需要定义以下推导指引：\ntemplate &lt;typename ElementType, typename... TailArgTypes&gt;FixedArray(ElementType, TailArgTypes...) -&gt; FixedArray&lt;ElementType, sizeof...(TailArgTypes) + 1&gt;;\n推导规则的工作原理是定义一个假想的函数模板，编译器会将无法默认规则无法推导的初始化表达式作为该函数模板的实参，再通过函数模板的推导规则来获取我们定义的类模板实参推导结果。就拿FixedArray作为例子，当编译器遇到一个无法被默认推导规则推导的规则时，如：\nFixedArray array&#123;1, 2, 3, 4&#125;;\n编译器会尝试查找FixedArray的推导规则，在这个例子中，只有上文定义的一条推导规则。在编译器查找到之后，它会尝试“想象”一个函数模板调用：\ntemplate &lt;typename ElementType, typename... TailArgTypes&gt;FixedArray(ElementType, TailArgTypes...) /*忽略返回类型和函数体*/;FixedArray(1, 2, 3, 4);\n然后编译器就可以从这一调用推导出ElementType=int, TailArgTypes=&lt;int, int, int&gt;，从而成功推导出类模板的实参。当然，这一推导规则可以用我们前文所讲的[[#包索引]]简化：\ntemplate &lt;typename ... ArgTypes&gt;FixedArray(ArgTypes...) -&gt; FixedArray&lt;ArgTypes...[0], sizeof...(ArgTypes)&gt;;\n模板模板形参我们现在有了可以接受类型的类型模板形参，有了可以接受对象的非类型模板实参（即NTTP），还有什么是模板形参接受不了的呢？就是模板。为了解决这一问题，C++引入了模板模板形参（Template Template Parameter，很绕口就对了），模板模板形参的声明语法如下：\ntemplate &lt;template &lt;模板形参列表&gt; 模板类型 标识符&gt;template &lt;template &lt;模板形参列表&gt; 模板类型 标识符 = 默认值&gt;template &lt;template &lt;模板形参列表&gt; 模板类型 ... 标识符&gt;\n其中，模板类型可以为class、typename、concept（C++26加入）、auto（C++26加入）。我们此处只讲解typename一种。\ntemplate &lt;typename ElementT&gt;struct MyArray &#123;\t//something...&#125;;template &lt;typename KeyT, typename ValueT, template &lt;typename&gt; typename ContainerT&gt;struct Map &#123;\tContainerT&lt;KeyT&gt; _keys;\tContainerT&lt;ValueT&gt; _keys;&#125;;auto main() -&gt; int &#123;\tMap&lt;int, std::string, MyArray&gt; my_map;&#125;\n其中，template &lt;typename&gt; typename ContainerT即为一个模板模板形参。ContainerT接受一个模板类作为实参（typename ContainerT说明ContainerT是一个类型），且该模板类拥有一个类型模板形参（template &lt;typename&gt;说明Container是一个模板，且模板形参列表为&lt;typename&gt;）。我们可以将符合这一要求的类模板（比如MyArray）赋给ContainerT。\n成员函数模板成员函数模板与类模板的相关性不大，类模板和普通的类都可以有成员函数模板，类模板的模板形参在其成员函数模板中都可用：\nclass NonTemplateClass &#123;\ttemplate &lt;typename T&gt;\tauto templateFunction() -&gt; void &#123;&#125;\tauto regularFunction() -&gt; void &#123;&#125;&#125;;template &lt;typename ClassT&gt;class TemplateClass &#123;\t//类模板的模板形参在其成员函数模板中都可用\ttemplate &lt;typename T = ClassT&gt;\tauto templateFunction() -&gt; void &#123;&#125;\tauto regularFunction() -&gt; void &#123;&#125;\t//构造函数也可以是函数模板\ttemplate &lt;typename F&gt;\tTemplateClass() &#123;&#125;&#125;;\n注意，一个类的析构函数不能是函数模板。成员模板函数与一般的模板函数没有太大差别，故此处不深入讲解。\n类模板与形参包与函数模板一样，形参包在类模板中亦有广泛的使用，其中最为知名的莫过于std::tuple。通过使用形参包，std::tuple有了在一个对象中存储不同类型对象的能力。我们用一段简单的例子来演示形参包在类模板中的使用：\ntemplate &lt;typename ... ElementT&gt;struct MyTuple &#123;\tstd::tuple&lt;ElementT...&gt; _storage;\tMyTuple(ElementT&amp;&amp; ... args)\t\t: _storage(std::forward&lt;ElementT&gt;(args)...)\t&#123;&#125;&#125;;\n\n别名模板与变量模板除了函数和类之外，类型别名与变量都可以成为模板，分别称作别名模板（Alias Template）和变量模板（Variable Template）。这两类模板的作用会在后面几篇教程详细讲解，在此处我们仅做简单演示：\n//别名模板template &lt;typename T&gt;using Alias = T;//变量模板template &lt;typename T&gt;std::size_t size = sizeof(T);auto main() -&gt; int &#123;\tstd::println(&quot;&#123;&#125;&quot;, size&lt;Alias&lt;int&gt;&gt;);//输出4，即int类型的大小&#125;\nCompiler Explorer链接\n待决名typename消岐义符我们使用一段代码来引入待决名（Dependent Name）这一概念：\ntemplate &lt;typename T&gt;auto getIterator(std::vector&lt;T&gt; const &amp;v) -&gt; void &#123;\tstd::vector&lt;T&gt;::const_iterator it = v.begin();&#125;auto main() -&gt; int &#123;\tstd::vector&lt;int&gt; v&#123;&#125;;\tgetIterator(v);&#125;\nCompiler Explorer链接上面这段代码在经过clang编译后会产生以下错误：\n&lt;source&gt;:5:2: error: missing &#x27;typename&#x27; prior to dependent type name &#x27;std::vector&lt;T&gt;::const_iterator&#x27;    5 |         std::vector&lt;T&gt;::const_iterator it = v.begin();      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      | typename 1 error generated.\n报错的原因也很简单：由于std::vector&lt;T&gt;是一个依赖于模板形参T的类型，所以编译器在实例化之前并不知道std::vector&lt;T&gt;里面有什么东西。在编译器的视角中，std::vector&lt;T&gt;::const_iterator可以是：\n\n一个静态成员变量\n一个成员类型别名\n一个静态成员函数\n…显然，编译器并不知道应该选择哪一种来解释const_iterator，所以产生了这样的报错，我们称std::vector&lt;T&gt;::const_iterator是一个待决名。为了避免报错，我们应该显式地告诉编译器（即“消岐义”，Disambiguate），const_iterator是一个成员类型别名：\n\ntemplate &lt;typename T&gt;auto getIterator(std::vector&lt;T&gt; const &amp;v) -&gt; void &#123;\t//在前面加上typename关键字来说明这是个类型\ttypename std::vector&lt;T&gt;::const_iterator it = v.begin();&#125;auto main() -&gt; int &#123;\tstd::vector&lt;int&gt; v&#123;&#125;;\tgetIterator(v);&#125;\n那么，我们应该在何时使用typename进行消岐义呢？\n\n在模板（包括别名模版）的声明或定义中，不是当前实例化的成员且取决于某个模板形参的名字不会被认为是类型，除非使用关键词typename或它已经被设立为类型名（例如用typedef声明或通过用作基类名）。\n\n将这句话拆分成几个部分：\n\n在模板的声明或定义中\n不是当前实例化的成员且取决于某个模板形参的名字\n除非使用关键词typename或它已经被设立为类型名对应到上面的例子中：\n我们在一个函数模板getIterator的定义中，符合\nstd::vector&lt;T&gt;::const_iterator不是当前实例化的成员，同时取决于我们的模板形参T，符合所以编译器不会认为std::vector&lt;T&gt;::const_iterator是一个类型名，所以我们需要使用typename来进行消岐义。当然，如果名字并非待决，我们也可以在前面使用typename。通俗来讲就是如果编译器已经知道某个标识符是个类型，你也可以继续跟编译器重复说这是个类型（当然不少编译器都会给你一个warning说这不是必要的）。\n\ntemplate消岐义符我们同样以一个例子做引入：\ntemplate &lt;typename T&gt;struct Foo &#123;\ttemplate &lt;typename U&gt;\tauto foo() -&gt; void &#123;&#125;&#125;;template &lt;typename T&gt;auto bar() -&gt; void &#123;\tFoo&lt;T&gt; foo_inst&#123;&#125;;\tfoo_inst.foo&lt;T&gt;();&#125;\nCompiler Explorer链接这段代码同样会发生编译错误，clang编译器的报错如下：\n&lt;source&gt;:10:11: error: use &#x27;template&#x27; keyword to treat &#x27;foo&#x27; as a dependent template name   10 |         foo_inst.foo&lt;T&gt;();      |                  ^      | template 1 error generated.\n与typename类似，编译器不认为foo_inst.foo&lt;T&gt;是一个模板，所以相应的，我们需要加上template消岐义符：\ntemplate &lt;typename T&gt;struct Foo &#123;\ttemplate &lt;typename U&gt;\tauto foo() -&gt; void &#123;&#125;&#125;;template &lt;typename T&gt;auto bar() -&gt; void &#123;\tFoo&lt;T&gt; foo_inst&#123;&#125;;\tfoo_inst.template foo&lt;T&gt;();&#125;\n使用template消岐义的规则与typename类似：\n\n模板定义中不是当前实例化的成员的待决名同样不被认为是模板名，除非使用消歧义关键词template，或它已被设立为模板名。\n\n对应上面的例子：\n\n我们在bar模板函数的定义中\n且Foo&lt;T&gt;不是当前实例化的成员故foo_inst.foo&lt;T&gt;亦是待决名，故编译器不认为它是一个模板。同样的，template消岐义符也可以用在不需要消岐义的标识符前面。\n\n绑定规则模板中标识符的绑定规则可以根据该标识符是否待决分为两类：\n\n非待决名在模板定义点查找并绑定。即使在模板实例化点有更好的匹配，也保持此绑定。\n待决名的绑定则延迟到查找发生时，即实例化时。我们用一段代码来理解以上规则：\n\nauto foo(double dummy) -&gt; void &#123;\tstd::println(&quot;foo(double) called&quot;);&#125;template &lt;typename T&gt;struct Bar &#123;\tauto meow() -&gt; void &#123;\t\tfoo(42);\t&#125;&#125;;auto foo(int dummy) -&gt; void &#123;\tstd::println(&quot;foo(int) called&quot;);&#125;auto main() -&gt; int &#123;\tfoo(42);\tBar&lt;void&gt; bar_inst;\tbar_inst.meow();&#125;\nCompiler Explorer链接运行这段代码，输出结果为：\nfoo(int) calledfoo(double) called\n为什么会出现这个结果呢？main函数中对foo(42)函数的调用很直观的绑定到了foo(int)，但是在Bar&lt;T&gt;::meow 中的foo(42)是一个非待决名，非待决名在模板的定义点查找并绑定，而非在实例化点绑定。所以当编译器编译到了meow函数时，它会立刻开始查找目前已经定义的foo函数，而由于此时编译器还没有看到后面的foo(int)，所以此处只能绑定到已知的foo(double)。但如果在meow中foo是一个待决名，那么绑定会在实例化的时候发生。\n查找规则auto bar() -&gt; void &#123; std::println(&quot;::bar() called&quot;); &#125;template &lt;typename T&gt;struct Base &#123;\tauto bar() -&gt; void &#123; std::println(&quot;Base::bar() called&quot;); &#125;&#125;;template &lt;typename T&gt;struct Foo : public Base&lt;T&gt; &#123;\tauto dependent() -&gt; void &#123;\t\tthis-&gt;bar();\t&#125;\tauto independent() -&gt; void &#123;\t\tbar();\t&#125;&#125;;auto main() -&gt; int &#123;\tFoo&lt;void&gt; foo;\tfoo.dependent();\tfoo.independent();&#125;\nCompiler Explorer链接运行上面的代码，输出结果为：\nBase::bar() called::bar() called\n首先我们明确在dependent和independent函数中，由于我们没有使用任何的作用域解析操作符::，对bar进行的查找都是无限定名字查找（UDL，Unqualified Name Lookup）。同时，在dependent中，bar是一个依赖于Base&lt;T&gt;的待决名，而在independent中，bar是一个非待决名。非待决名和待决名的查找规则有所不同，高度概括地说：\n\n非待决名在模版定义的时候就进行无限定名字查找。\n待决名的名字查找会推迟到模板实例化时。这称作二阶段名字查找（Two-phase Name Lookup）所以对于independent中对bar的调用，编译器在该类模板定义时就会进行查找。按照UDL的查找顺序，编译器首先会在本类中查找（注意不会查找父类Base&lt;T&gt;），在本类中查找不到bar后编译器会进一步查找全局命名空间，随后就会查找到在全局命名空间中的bar。而对于dependent中对bar的调用，编译器会在实例化，即main函数中Foo&lt;void&gt;一行时进行查找，由于所有模板形参都已确定，编译器可以对父类进行查找，所以会查找到父类中对bar。\n\n模板特化与部分特化模板全特化模板特化（Template Specialization），说的直白点就是让模板能够对某些模板实参进行特殊处理，以前文中的FixedArray为例（为了简洁我们将其长度固定为8）：\ntemplate &lt;typename ElementT&gt;struct FixedArray &#123;\tElementT storage[8];&#125;;\n我们都知道在C++中，一个bool需要占用完整的一个字节，所以FixedArray&lt;bool&gt;就会占用8个字节。但是bool的信息存储只需要用到一个字节中的一位，所以我们想通过某种方式来优化FixedArray&lt;bool&gt;，来使其只占用一个字节，这时候我们就要用到模板全特化（又称模板显式特化，Explicit (Full) Template Specialization）：\n//模板主定义template &lt;typename ElementT&gt;struct FixedArray &#123;\tElementT storage[8];&#125;;//针对bool特化模板template &lt;&gt;struct FixedArray&lt;bool&gt; &#123;\tstd::int8_t storage;&#125;;auto main() -&gt; int &#123;\tFixedArray&lt;int&gt; array1;\tFixedArray&lt;bool&gt; array2;\tstd::println(&quot;&#123;&#125; &#123;&#125;&quot;, sizeof(array1), sizeof(array2));&#125;\nCompiler Explorer链接可以看到，array2的大小仅为一个字节，说明我们的模板特化起了作用。\n全特化函数模板对于函数模板的全特化来说，其语法如下：\ntemplate &lt;&gt;函数定义（或声明）\n如果模板实参能从函数参数列表中推导，那么我们可以省略模板实参：\n//模板主定义template &lt;typename T&gt;auto foo(T t) -&gt; T &#123;\treturn t;&#125;//T=int的全特化template &lt;&gt;auto foo&lt;int&gt;(int t) -&gt; int &#123;\treturn 42;&#125;//T=double的全特化，由于可以推导模板实参所以不必指定template &lt;&gt;auto foo&lt;double&gt;(double t) -&gt; double &#123;\treturn 114.514;&#125;auto main() -&gt; int &#123;\tstd::println(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, foo(true), foo(1), foo(4.2));&#125;\nCompiler Explorer链接注意一点，所有的模板特化都应该位于在第一次会引起隐式实例化的使用前，比如下面的代码不能通过编译：\n//模板主定义template &lt;typename T&gt;auto foo(T t) -&gt; T &#123;\treturn t;&#125;auto main() -&gt; int &#123;\t//引发foo&lt;int&gt;隐式实例化\tstd::println(&quot;&#123;&#125;&quot;, foo(1));&#125;//T=int的全特化，由于特化位于隐式实例化之后，所以编译不通过template &lt;&gt;auto foo&lt;int&gt;(int t) -&gt; int &#123;\treturn 42;&#125;\n注意要分清楚全特化与显式实例化之间的差异，两者的语法很接近，但特化的函数模板与模板主定义之间没有关系，而显式实例化是基于模板主定义进行的实例化：\n//模板主定义template &lt;typename T&gt;auto foo(T t) -&gt; T &#123;\treturn t;&#125;//这是一个特化，注意template后面带有一对空尖括号template &lt;&gt;auto foo(int t) -&gt; int &#123;\treturn 42;&#125;//这是一个显式实例化，注意template后面直接跟着函数声明template auto foo(double) -&gt; double;\n注意，特化的函数模板可以跟主模板具有不同的说明符（inline&#x2F;constexpr&#x2F;constinit&#x2F;conseval）：\ntemplate &lt;typename T&gt;auto foo(T) -&gt; void &#123;&#125;template &lt;&gt;inline auto foo(int) -&gt; void &#123;&#125; template &lt;typename T&gt;inline auto bar(T) -&gt; T &#123;&#125;template &lt;&gt;auto bar(int) -&gt; int &#123;&#125;         // OK，没有内联\n全特化类模板类模板全特化的语法与函数模板类似：\ntemplate &lt;&gt;类定义（或声明）\n一个简单的小例子（虽说这里value应该是constexpr变量，但是由于我们还没有讲到相关知识，故省略）：\n//类模板主定义template &lt;typename T&gt;struct isVoid &#123;\tinline static bool value = false;&#125;;//T=void全特化template &lt;&gt;struct isVoid&lt;void&gt; &#123;\tinline static bool value = true;&#125;;auto main() -&gt; int &#123;\tstd::println(&quot;&#123;&#125; &#123;&#125;&quot;, isVoid&lt;int&gt;::value, isVoid&lt;void&gt;::value);&#125;\nCompiler Explorer链接注意，类模板的特化相当于一个全新的，与原类模板主声明无关的类。我们可以随意向类模板的特化中添加成员：\n//类模板主定义template &lt;typename T&gt;struct MathUtils &#123;\tauto abs(T t) -&gt; T &#123; \t\tstd::println(&quot;MathUtils&lt;WhatSoEver&gt;::abs() called&quot;);\t\treturn std::abs(t); \t&#125;&#125;;//T=int全特化template &lt;&gt;struct MathUtils&lt;int&gt; &#123;\tauto abs(int t) -&gt; int &#123; \t\tstd::println(&quot;MathUtils&lt;int&gt;::abs() called&quot;);\t\treturn t &lt; 0 ? -t : t; \t&#125;\tauto sqrt(int t) -&gt; int &#123; return std::sqrt(t); &#125;&#125;;auto main() -&gt; int &#123;\tMathUtils&lt;double&gt; utils_double;\tMathUtils&lt;int&gt; utils_int;\tutils_double.abs(-4.2);\tutils_int.abs(-114514);\t//sqrt只存在于MathUtils&lt;int&gt;特化中，故下面这行代码无法通过编译\t//utils_double.sqrt(4.2);\tutils_int.sqrt(4);&#125;\nCompiler Explorer链接\n全特化类模板成员在类体外定义显式特化的类模板的成员时，不需要使用template&lt;&gt;前缀，除非它是某个被特化为类模板的显式特化的成员类模板的成员：\n\n成员函数及成员函数模板：\n\n//类模板主定义template &lt;typename T&gt;struct Foo &#123;\tauto bar() -&gt; void &#123;&#125;\tauto meow() -&gt; void &#123;&#125;\ttemplate &lt;typename U&gt;\tauto templated() -&gt; void &#123;&#125;&#125;;//T=void全特化template &lt;&gt;struct Foo&lt;void&gt; &#123;\t//可以在类内定义\tauto bar() -&gt; void &#123;&#125;\tauto meow() -&gt; void;\ttemplate &lt;typename U&gt;\tauto templated() -&gt; void;&#125;;//也可以在类内声明，类外定义auto Foo&lt;void&gt;::meow() -&gt; void &#123;&#125;//注意无论是类内还是类外定义，三个函数都不需要使用template &lt;&gt;做前缀//这是由于三个函数（模板）都在全特化的类模板中声明，故都可以看作一个独立类（即类模板的特化）的成员，故不需要额外的特化前缀template &lt;typename U&gt;auto Foo&lt;void&gt;::templated() -&gt; void &#123;&#125;\n\n成员类及成员类模板：\n\ntemplate &lt;typename T&gt;struct Foo &#123;\t//成员类\tstruct Bar &#123;&#125;;\t//成员类模板\ttemplate &lt;typename U&gt;\tstruct Meow &#123;&#125;;&#125;;template &lt;&gt;struct Foo&lt;int&gt; &#123;\tstruct Bar;\ttemplate &lt;typename U&gt;\tstruct Meow &#123;&#125;;&#125;;//同样的，由于都已在类模板的全特化中声明，Bar和Meow均不需要template &lt;&gt;前缀struct Foo&lt;int&gt;::Bar &#123;&#125;;\n我们还可以通过对类模板的隐式实例化进行特化来单独特化类模板中的部分成员，此时我们才需要用到template &lt;&gt;前缀：\ntemplate &lt;typename T&gt;struct Foo &#123;\tauto foo() -&gt; void &#123;\t\tstd::println(&quot;Unspecialized foo()&quot;);\t&#125;\tauto bar() -&gt; void &#123;\t\tstd::println(&quot;Unspecialized bar()&quot;);\t&#125;&#125;;//注意，为了对类模板的隐式实例化进行特化，这里我们需要加上template &lt;&gt;前缀template &lt;&gt;auto Foo&lt;int&gt;::foo() -&gt; void &#123;\tstd::println(&quot;Specialized foo()&quot;);&#125;auto main() -&gt; int &#123;\tFoo&lt;void&gt; foo_void;\tFoo&lt;int&gt; foo_int;\tfoo_void.foo();\tfoo_void.bar();\tfoo_int.foo();\tfoo_int.bar();&#125;\nCompiler Explorer链接模板特化也可以进行嵌套，比如特化一个类模板中的特定成员函数模板：\ntemplate &lt;typename T&gt;struct Foo &#123;\ttemplate &lt;typename U&gt;\tauto bar() -&gt; void &#123;&#125;&#125;;template &lt;&gt;template &lt;&gt;auto Foo&lt;int&gt;::bar&lt;double&gt;() -&gt; void &#123;&#125;//针对Foo&lt;int&gt;::bar&lt;double&gt;进行特化\n全特化变量模板全特化变量模板会在后续章节中深入讲解，此处仅提供一个简单的例子说明：\n//变量模板主定义template &lt;typename T&gt;std::string_view getTypeName = &quot;&lt;unknown type&gt;&quot;;//T=int全特化template &lt;&gt;std::string_view getTypeName&lt;int&gt; = &quot;int&quot;;//T=double全特化template &lt;&gt;std::string_view getTypeName&lt;double&gt; = &quot;double&quot;;auto main() -&gt; int &#123;\tstd::println(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, getTypeName&lt;void&gt;, getTypeName&lt;int&gt;, getTypeName&lt;double&gt;);&#125;\nCompiler Explorer链接\n模板部分特化模板全特化，是提供一个定义给一组具体的模板实参。而所谓模板部分特化（又译模板偏特化，Partial Template Specialization）是将一个定义提供给一组具有某些特征的模板实参。我们以一个例子做引入：\ntemplate &lt;typename T&gt;std::string_view typeCategory = &quot;&lt;unknown&gt;&quot;;//对所有指针进行部分特化template &lt;typename T&gt;std::string_view typeCategory&lt;T *&gt; = &quot;&lt;pointer&gt;&quot;;//对所有左值引用进行部分特化template &lt;typename T&gt;std::string_view typeCategory&lt;T &amp;&gt; = &quot;&lt;Lvalue Reference&gt;&quot;;//对所有右值引用进行部分特化template &lt;typename T&gt;std::string_view typeCategory&lt;T &amp;&amp;&gt; = &quot;&lt;Rvalue Reference&gt;&quot;;auto main() -&gt; int &#123;\tstd::println(\t\t&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;,\t\ttypeCategory&lt;int&gt;,//&lt;unknown&gt;\t\ttypeCategory&lt;int *&gt;,//&lt;pointer&gt;\t\ttypeCategory&lt;int const *&gt;,//&lt;pointer&gt;\t\ttypeCategory&lt;int &amp;&gt;,//&lt;Lvalue Reference&gt;\t\ttypeCategory&lt;int &amp;&amp;&gt;//&lt;Rvalue Reference&gt;\t);&#125;\nCompiler Explorer链接在有多个模板形参时，完全指定一部分模板实参也是偏特化的一种：\n//类模板主定义template &lt;typename T1, typename T2&gt;struct Foo &#123;\tstatic auto foo() -&gt; void &#123;\t\tstd::println(&quot;Foo&lt;T1, T2&gt;::foo() called&quot;);\t&#125;&#125;;//对T1=int进行偏特化，T2不做指定template &lt;typename T2&gt;struct Foo&lt;int, T2&gt; &#123;\tstatic auto foo() -&gt; void &#123;\t\tstd::println(&quot;Foo&lt;int, T2&gt;::foo() called&quot;);\t&#125;&#125;;auto main() -&gt; int &#123;\tFoo&lt;void, double&gt;::foo();\tFoo&lt;float, int&gt;::foo();\t//偏特化匹配所有第一个模板实参为int的实例化\tFoo&lt;int, void&gt;::foo();\tFoo&lt;int, char&gt;::foo();&#125;\nCompiler Explorer链接注意，与模板全特化不同，模板偏特化只能特化类模板与变量模板。模板偏特化这一特性十分强大，这相当于允许我们对模板实参进行模式匹配，并根据不同的匹配结果进行不同的处理，这一特性直接构成了我们后面要讲的模板元编程的核心工具之一。模板偏特化的语法与全特化大致相同，故此处不再赘述。\n","tags":["C++","Metaprogramming","Tutorial","Template"]},{"title":"Probability and Statistics for Engineering Lecture 1-2 Notes","url":"/2025/09/18/pse-1/","content":"Basic Ideas in ProbabilityBasic Concepts\n  \n    \n      Definition: Random Experiment\n\n    \n    \n      A random experiment, often simply called an experiment, represents the realization or observation of a random phenomenon and has the following characteristics:\n\nit can be repeated under the same conditions;\nall possible outcomes are clearly known;\nexactly one of these possible outcomes occurs each time, but it cannot be determined in advance which outcome will occur.\n\n\n    \n  \n\n\n  \n    \n      Definition: Sample Point and Sample Space\n\n    \n    \n      Each possible fundamental outcome of a random experiment is called a sample point, usually denoted as . A set that includes all sample points of the experiment is called the sample space, usually denoted as .\n\n    \n  \n\n\n  \n    \n      Definition: Event\n\n    \n    \n      From a set theory perspective, a random event, or simply event, is a subset of the sample space , typically denoted by uppercase letters. If the outcome is a sample point in event , then we say that event  happens.\n\n    \n  \n\n\nInclusion :  happens when  happens.\nSum/union /: at least one of  and  happens.\nProduct/intersection /:  and  both happen.\nDifference /:  happens and  does not happen.\nMutually exclusive/disjoint :  and  cannot happen at the same time.\nComplement /: either  or  happens, denoted as  or .\n\nThe operations of events obey certain rules similar to the rules of set:\n\nCommunicative laws;\nAssociative laws;\nDistributive laws;\nDe Morgan’s laws:Having defined the sample space and random event, we can now discuss the probability of events:\n\n\n  \n    \n      Definition: Probability\n\n    \n    \n      Probability measure, or simply probability, is a real-valued function defined on subsets of the sample space , satisfying the following three axioms:\n\nNon-negativity: .\nNormalization: .\nAdditivity: for any countable number of mutually exclusive events , we have\n\n\n    \n  \n\nFrom the three axioms, we can derive many useful properties:\n\n  Proof: trivial.\n\nFinite additivity: for any finite sequence of mutally exclusive events ,  Proof: straightforward of the additivity axiom with  for all .\n\nThe complement rule: .  Proof: immediate from the finite additivity with .\n\nThe numeric bound: .  Proof: straightforward from the complement rule.\n\nMonotonicity: if , then  and .  Proof: from the finite additivity, since , we have . We also know that , so we have .\n\nThe addition law: .\n\nThe inclusion-exclusion principle:  Proof: We prove this by induction on .  Base case: for :    trivially holds.  for :    is exactly the same as the addition law.\n  Inductive case: Consider events sequence , then:  $$  \\bigcup^{n+1}{i=1}A_i=\\left(\\bigcup^n{i=1}A_i\\right)\\cup A_{n+1}    P\\left(\\bigcup^{n+1}{i=1}A_i\\right)=P\\left(\\bigcup^n{i=1}A_i\\right)+P(A_{n+1})-P\\left(\\left(\\bigcup^n_{i=1}A_i\\right)\\cap A_{n+1}\\right)    \\left(\\bigcup^n_{i=1}A_i\\right)\\cap A_{n+1}=\\bigcup^n_{i=1}(A_i\\cap A_{n+1})    B_i=A_i\\cap A_{n+1}    \\bigcup^n_{i=1}(A_i\\cap A_{n+1})=\\bigcup^n_{i=1}B_i    P\\left(\\bigcup^n_{i=1}B_i\\right)=\\sum^n_{k=1}(-1)^{k-1}\\sum_{1\\le i_1&lt;\\dots&lt;i_k\\le n}P(B_{i_1}\\cap\\dots\\cap B_{i_k})  $$\n\n\nComputing Probabilities\n  \n    \n      Addition and Multiplication Principles\n\n    \n    \n      Addition principle: If there are  types of methods to complete a task, with  specific methods in the th type, then the total number of specific methods to complete this task is:\nMultiplication principle: If there are  steps to complete a task, with  possible methods for the th step, then the total number of methods to complete this task is:\n\n    \n  \n\n\n  \n    \n      Definition: Permutation and Combination\n\n    \n    \n      Permutation: If  elements are randomly selected without replacement from  distinct elements () and placed in order, then the number of different permutation is\nCombination: The number of combinations of  elements randomly selected without replacement from  distinct elements (), where the order does not matter, is given by\n\n    \n  \n\n\n  \n    \n      Example\n\n    \n    \n      Suppose a class of  students has been allocated  () concert tickets by the university. The teacher decides to distribute the tickets by drawing lots.The teacher prepares a hat containing  slips of paper, with  slips marked with 1 and the remaining slips marked with 0.The students take turns drawing sslips from the hat, and those who draw a slip marked with a 1 will get a concert ticket.If you are one of the students in the class and you really want to get a ticket, would you choose to draw early or late?\n\n    \n  \n\nSolution. The essential question is that, suppose you are the th to draw a slip, does the probability depend on ?Considering the ticket drawing as a random experiment, then each possible outcome of the drawing process can be represented by a -digit binary number, with  digits being 1.Then the number of sample points is . w.l.o.g. we assume that . Then let  denote the event that you get a ticket, so ,\n\n  \n    \n      Example\n\n    \n    \n      There are  student in a class with student IDs . Now we prepare  gifts numbered with each possible student IDs. Then everyone randomly select their gift from a big bag. What’s the probability that at least one student get a gift with his/her own ID?\n\n    \n  \n\nSolution. Each permutation of  is a sample point, representing the gift numbers corresponding to students with IDs . So . Let  be the event that at least one student gets his/her own gift, then directly determining  is not so straightforward.Let  be the event that the student with ID  get his/her own gift, thenThe events  are very clear and their probability computation is simple:Put these together, we have:\nGeometric Model of ProbabilityThe classical model of probability assumes finite number of sample points and equal likelihood. Another model, called the geometric model of probability, is a natural extension of the classical model to an infinite number of sample points while maintaining equal likelihood.\n\n  \n    \n      Definition: Geometric Model of Probability\n\n    \n    \n      If a random experiment can be represented as randomly throwing a point onto a bounded region , where the point is equally likely to land at any position within the region, then the probability model of the experiment is called a geometric model of probability. Let  be the event that the point lands at a subregion  of , then the probability of event  is computed as\n\n    \n  \n\n\n  \n    \n      Example\n\n    \n    \n      Bertrand’s paradox: Consider a circle with radius 1. What is the probability that a randomly draw chord of the circle is longer than the side of the inscribed equilateral triangle of the circle?\n\n    \n  \n\nSolution 1Solution 2Solution 3Possible solution 1. Take a radius of the circle , and randomly choose a point  on the radius, then draw a chord through  orthgonal to .By elementary geometry,  intersects the triangle at the midpoint of , say . Then the sample space is all points on .For the chord to be longer than the side of the triangle,  must fall on , therefore, the probability isPossible solution 2. Take a point on the circle, say , draw the tangent to the circle through .Then randomly choose another point  on the circle, and draw a chord by connecting  and  that forms a random angle  with the tangent.Then the sample space is , and for the chord to be longer than the side of the triangle, we need .Therefore, the probability isPossible solution 3. Randomly choose a point  within the circle and draw a chord with  as the midpoint.For the chord to be longer than the side of the inscribed equilateral triangle,  must fall within the inscribed circle of the triangle, whose radius is .Then the sample space is the original circle, the event of interest is the inscribed circle.Therefore, the probability is\n\nBoth of the three solutions are correct. The reason why the probabiliy varies across different solutions is that the hypothesis “the chord is randomly drawn” is not clearly defined. Different assumptions of equal likelihood lead to different sample spaces:\n\nSolution 1: equally likely chosen on a radius, so the sample space is the radius.\nSolution 2: equally likely chosen on the circle, so the sample space is the circle boundary.\nSolution 3: equally likely chosen within the circle, so the sample space is the whole circle area.\n\nTherefore, when computing probabilities, it is crucial to clearly define the sample apce first.\nConditional Probability and Independence\n  \n    \n      Definition: Conditional Probability\n\n    \n    \n      Let  and  be two random events and . Then the conditional probability of event  given that event  occurs is defined as\n\n    \n  \n\nThe idea behind this definition is that if event  has occured, the sample space becomes  instead of .\n\n  \n    \n      Example\n\n    \n    \n      You are playing a poker game where you are dealt with 5 cards face down. If one of the cards that you are dealt lands face up, showing the Ace of spades, what is the probability of having a royal flush now?\n\n    \n  \n\nSolution. Let  be the event of having a royal flush. The probability of  is straightforward:Let  be the event that one of the 5 cards is the Ace of spades, then the number of sample points in  is . is the event of a royal flush of spades. So the probability of  given  is\n\n  \n    \n      Multiplication Law\n\n    \n    \n      Let  and  be two random events and . Then .\n\n    \n  \n\n\n  \n    \n      Law of Total Probability\n\n    \n    \n      Let  and  be two random events, then (assume that  if )More generally, if  are  mutually exclusive random events, and , then we call  a partition of the sample space , and\n\n    \n  \n\nJust like how the addition law generalize to the inclusion-exclusion law, the multiplication law also has a generalized version, called the chain rule for random events.s\n\n  \n    \n      Chain Rule\n\n    \n    \n      assume that .\n\n    \n  \n\n\n  \n    \n      Bayes’ Theorem\n\n    \n    \n      Let  be random events and  is a partition of the sample space. Then for any event  s.t. , we have is the probability of  given that  occurs, also termed the posterior possibility of . is called the prior probability or marginal probability of , which refers to the probability value in the absence of any other prior information.\n\n    \n  \n\nA intuitive understanding of the Bayes’ rule and the law of total probability is:\n\nthe law of total probability can be viewed as from cause to effect, since we are calculating the probability of the outcome event based on all possible causes.\nthe conditional probability  obtained by the Bayes’ rule can be viewed as the probability of the specifc cause  led to the observed outcome . Simply put, we are reasoning from effect to put.\n\n\n  \n    \n      Definition: Independence\n\n    \n    \n      Let  all denote random events.\n\n and  are said to be independent if .\n are said to be mutually independent if for every subset of these events  (, ), we have\n\n\n    \n  \n\n\n  \n    \n      Caution\n\n    \n    \n      Pairwise independence does not imply mutual independence.\n\n    \n  \n\nIndependence can sometimes rely on the occurrence of some random event. This is the concept of the conditional independence.\n\n  \n    \n      Definition: Conditional Independence\n\n    \n    \n      Let  all denote random events.  are said to be conditionally independent conditioned on  if for every subset of the events,  (, ), we have\n\n    \n  \n\n\n  \n    \n      Example\n\n    \n    \n      Draw three cards from a properly shuffled standard deck, with replacement and reshuffling. Let  be the event that “card 1 and 2 have the same suit”,  be the event that “card 2 and 3 have the same suit”,  be the event that “card 1 and 3 have the same suit”. Are  mutually independent?\n\n    \n  \n\nSolution. It is trivial to show that . And  are the same event “card 1, 2, 3 have the same suit”, so it is also trivial that .Therefore, we havebutSo the three events are pairwise independent, but not mutually independent.\n","tags":["Notes","Probability and Statistics for Engineering"]}]